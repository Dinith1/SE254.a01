<h1>Assignment 1 &mdash; Creating Tests</h1>
  
<h2>Overview</h2>

<p>The main goal of this assignment is to write tests that will detect faults
in code.

<table border=""><tbody>
<tr>
<th align="left">Due</th>
<td>17:00hr Friday 3 August (Week 3)</td>
</tr>
<tr>
<th align="left">Worth</th>
<td>7.5%</td>
</tr>
<tr>
<th align="left">Submission</th>
<td>1 file <code>TestURIParser.java</code>
via <a href="http://adb.auckland.ac.nz">ADB</a>
</td>
</tr>
</tbody></table>

<h3>Updates</h3>
<ul>
<li>Any clarifications or corrections will be listed here.</li>
</ul>

<h2>Learning Outcomes</h2>
<p>On successfully completing this assignment, you should be able to:</p>
<ul>
  <li>construct a test suite.</li>
  <li>assess the quality of a test suite.</li>
  <li>Use JUnit to specify and execute a test suite.</li>
</ul>

<h2>Assignment Details</h2>
<h3>Functionality to Test</h3>

<p>
  A <b>URI</b> (variously known as <em>Universal Resource Identifier</em> or
  <em>Uniform Resource Identifier</em>) is used to identify things. A
  specified form of URI, the URL, is used to describe where to find resources
  (e.g., the address of a webpage). There are several parts to a URI that must
  be determined by any software using the URI. The code you are testing is
  supposed to, given a URI, say what the different parts are.
</p>
<p>
  The intent is that the implementation
  support <a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a>, however
  supporting the full standard would make the implementation to test too big
  for this assignment, so the assignment uses a restricted form. The
  functionality you are to test is specified in the JavaDoc supplied
  (see below), which should be considered the authority as to what to
  test.
</p>

<h3>Resources</h3>

<p>On the course website you will find a file <a>softeng254-a01.tar</a>. This
contains everything you need. Unpack it at an appropriate place.</p>
<p>In the files for this assignment, you will find:</p>
<dl>
<dt><tt>description.html</tt></dt>
<dd>This is a version of the assignment handout (Provided for your off-line
convenience). The Canvas version is the authoritative version.</dd>
<dt>11 jar files</dt>
<dd>
Each of these contains an implementation of the class
<code>uriparser.URIParser</code> and other support classes (such as
<code>uriparser.URI</code>). Some of them (those with names like 
<tt>badA.jar</tt>, <tt>badB.jar</tt>, and so on) contain implementations that
are known to contain a fault. One (<tt>good.jar</tt>) is <em>believed</em> to
contain no faults.
<dt><code>TestURIParser.java</code></dt>
<dd>
A template for the file you are to submit. Do not change the name of the
class <strong>or the package it is in</strong>.</dd>
<dt><tt>javadoc</tt></dt>
<dd>This is the JavaDoc pages describing the expected functionality of the <code>URIParser</code> and <code>URI</code> classes. You are to base your test suite on what is described by these files (but see the notes below). You should
  open <tt>javadoc/index.html</tt> in your browser.
</dl>
<p>The <code>URIParser</code> class uses other classes, but you do not
to test them (or rather, you will test them only by testing
<code>URIParser</code>). Examples are <code>URI</code>
and <code>ParseException</code>.
</p>

<h3>Requirements</h3>

<p>
  You are to create a <em>test suite</em> to test <code>URIParser</code> (the
  fully-qualified name is <code>uriparser.URIParser</code>).  Your test suite
  should detected all the faults in the "bad" implementations, and all tests
  should pass for the "good" implementation (assuming there are, in fact, no
  faults in that implementation!).
</p>
<p>
  All (deliberate) faults are due to the implementation not meeting the stated
  requirements, that is, they are detectable by basing tests only on what you
  see in the JavaDoc description.
</p>
<p>
  You create your test suite using JUnit by
  adding <a href="http://junit.org/junit4/">JUnit 4</a>-style tests
  to <code>TestURIParser.java</code>. <font color=red>Do not use JUnit
  5.</font> If you do, you are likely to use something that will interfere
  with the automatic marking system (see below).</p>

<p>
  JUnit 4 provides many annotations, most of which you should avoid. The
  nature of this assignment is that you will not get much benefit from them,
  and the time spent on figuring out how to use them properly would be better
  spent on the assignment itself.
</p>

<p>
  The one annotation you cannot
  avoid, <a href="http://junit.org/junit4/javadoc/latest/org/junit/Test.html"><code>@Test</code></a>,
  can take two parameters. One of these, <code>timeout</code>, will possibly
  be useful as it limits the time a test takes (e.g. in case of infinite
  loops). The other, <code>expected</code> (exception) <span style="color:
  red;">may not be used</span>. I want you to demonstrate your understanding
  of the use of <code>try/catch</code> to test exceptions. It's also removed
  in later versions of JUnit, so there's no point in getting into the habit of
  using it.</p>

<h2>Submission</h2>

<h3>Deliverables</h3>

<p>You are to submit a single file named <code>TestURIParser.java</code>
implementing the class <code>uriparser.TestURIParser</code> to
the <a href="http://adb.auckland.ac.nz">Assignment Dropbox</a>. You may submit
multiple times with only the most recent submission counting. You should use
the provided template as your starting point and you should not change the
name of the class (remember that the name of the class includes the package it
is in). <strong>Failure to follow these requirements will result in a mark of
zero.</strong> (Inability to follow instructions is an indication of poor
quality work, and thus inappropriate for a course on Quality Assurance.)</p>
<p>&nbsp;</p>

<h2>Working in groups</h2>
<p>
  General discussion about what needs to be accepted is acceptable (and
  encouraged). Development of specific test cases must be done individually.
  The work that you submit for grading must be your own work, and where work
  from other sources is used, it must be properly acknowledged and referenced.
</p>

<h2>Assessment</h2>

<p>This assignment worth 7.5% of your overall grade for SOFTENG254. Marks will
be allocated according to how well you demonstrate how well you understand how
to develop good quality tests.</p>

<p>Primarily your understanding will be determined by how many of the
implementations provided you correctly detect faults in (not, "how many
faults"), and how well you explain what you are testing.</p>

<p>Your tests will be partially assessed by an automatic marking system. If
the automatic marking system either cannot mark your submission, or marks it
incorrectly due to your submission not meeting the requirements, then you will
likely get zero for the assignment. (Think of it as you have been assigned to
write a class that fits into another system. Your boss is unlikely to be
impressed if you write a class that doesn't fit.) Note that if your class
cannot be compiled, then the automatic marking system will not be able to mark
it.</p>

<p>The assignment is marked out of 20 as follows:</p>
<ul>
<li>You will get 2 marks if all your tests pass on the "correct"
implementation.</li>

<li>You will get 0.5 marks for every implementation supplied to you if your
test suite indicates that that implementation has a fault. This means that one
of your tests must demonstrate that the implementation does the wrong
thing. It is <strong>not</strong> sufficient that JUnit indicates that the
test has failed --- the test must fail <em>and</em> the failure is clearly due
to the implementation containing a fault. (5 marks total)</li>

<li>Your tests will be run against another set of implementations that contain
faults. You will get 2 marks for each implementation your test suite correctly
indicates contains a fault. (10 marks total)</li>

<li>You will get 3 marks for how well you document your tests. (See
"Explaining the test case" below).</li>
</ul>

<p>In addition, you could be <strong>penalised</strong> as follows:</p>

<ol>
<li>50% of your mark out of 20 (as described above) if your tests execute an
assert<em>X</em>, fail, or similar method more than <strong>1000</strong>
times. This is a fairly generous limit, that is, it is much bigger than what
you should need. If you feel you need more, discuss it with me. Note that it
is not how many times these methods appear in your tests, but how many times
  they are <em>executed</em> (e.g if you put one in a loop then it
  is how many times that loop gets executed).</li>

<li>25% of your mark out of 20 (as described above) if your test code quality
is poor (See "Test Code Quality" below).</li>

</ol>

<p>Note also that using any external means (e.g. a tool) to develop your tests
is unacceptable. The goal of this assignment is not to come up with the tests,
but to demonstrate that you understand how to come up with good quality
tests. Use of external means will not convince me of your understanding.</p>

<h4>Explaining the test case</h4>

<p>It is a common situation that someone (usually you) looking at your code at
some point in the future thinks "I wonder if there is a test for this weird
case?" In order to help answer this kind of question, it is worth documenting
your test cases. It doesn't have to be super elaborate &mdash; just a sentence
or so that would help someone reading your tests figure out
what <em>general</em> case you are trying to test. Put such documentation in
JavaDoc comments for your test case methods. Documentation that makes no
attempt to explain <em>why</em> it is worth testing what you're testing or no
documentation at all are examples that are likely to lose marks. An example of
poor documentation is: "Tests the case for the input 'sillyvalue'". This
says <em>what</em> the test is, but not <em>why</em> this test is of good
quality. You need to give some idea as to why you think this particular input
will improve the quality of your test suite.</p>

<h4>Test Code Quality</h4>

<p>You should give some thought to how you organise your tests. You might even
consider developing auxiliary methods to make the test methods easier to
write. As well as documenting your individual methods, it is often helpful to
group them according to some more general scheme to help keep track of what is
being tested where. Lack of any organisation, poor test code, and code that
contains debugging print statements are all examples that are likely to lose
marks.</p>

<h3>Due dates and Penalties</h3>

<p>The due date for this assignment is as stated at the top of this page. Late
assignments will not be accepted without appropriate documentation (that is,
documentation provided by me in advance of the due date). Only submissions
made to ADB will be marked under any circumstances.</p>

<p>There is no specific presentation criteria. It is expected that your
writing and presentation will be to professional engineering standard, however
poor presentation will reduce your mark. It is not up to us to try to figure
out what you might be trying to say, you have to explain it clearly.</p>

<h3>Notes</h3>
<ol>
<li>The description given in the JavaDoc pages is may not be complete (or even
consistent). It is fairly representative* of what the original software
developer would have to work with, but that developer would also have to
figure out all the weird cases that haven't been mentioned. As the tester, you
have to do the same. If you are unsure about some case, <strong>ask</strong>.
<p>*<small>I lie. It is <em>much</em> better than most you are likely to encounter.</small></p>
</li>

<li>There may be small inconsistencies between what the JavaDoc says should
happen and what actually happens (especially for good.jar). <em>You should not
assume these are "faults" in the usual sense.</em> The problem may be with the
JavaDoc. Again, <strong>ask</strong>.</li>
</ol>
